{"README.md":"\r\n> このページを開く [https://itibanbosi.github.io/pxt-sinamon/](https://itibanbosi.github.io/pxt-sinamon/)\r\n\r\n## 拡張機能として使用\r\n\r\nこのリポジトリは、MakeCode で **拡張機能** として追加できます。\r\n\r\n* [https://makecode.microbit.org/](https://makecode.microbit.org/) を開く\r\n* **新しいプロジェクト** をクリックしてください\r\n* ギアボタンメニューの中にある **拡張機能** をクリックしてください\r\n* **https://github.com/itibanbosi/pxt-sinamon** を検索してインポートします。\r\n\r\n## このプロジェクトを編集します\r\n\r\nMakeCode でこのリポジトリを編集します。\r\n\r\n* [https://makecode.microbit.org/](https://makecode.microbit.org/) を開く\r\n* **読み込む** をクリックし、 **URLから読み込む...** をクリックしてください\r\n* **https://github.com/itibanbosi/pxt-sinamon** を貼り付けてインポートをクリックしてください\r\n\r\n#### メタデータ (検索、レンダリングに使用)\r\n\r\n* for PXT/microbit\r\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\r\n","_locales/ja/pxt-sinamon-jsdoc-strings.json":"{}","_locales/ja/pxt-sinamon-strings.json":"{\n  \"sinamon.car_derection2|block\": \"|%sinkou_houkou|へ |%time_sec|(秒)動く ,ﾊﾟﾜｰ|%Power|\",\n  \"sinamon.car_derection|block\": \"|%sinkou_houkou|へ動く,ﾊﾟﾜｰ|%Power|%\",\n  \"sinamon.car_stepmove3|block\": \"|%sinkou_houkou|へ|%step|(cm)動く\",\n  \"sinamon.car_stepmove4|block\": \"|%sinkou_houkou|で|%step|度回転する\",\n  \"sinamon.car_stepmove|block\": \"|%sinkou_houkou|へ動く,|%step|ステップ\",\n  \"sinamon.color_ID|block\": \"カラーID\",\n  \"sinamon.color_temp|block\": \"色温度\",\n  \"sinamon.colorcycle.cycle10|block\": \"cycle10\",\n  \"sinamon.colorcycle.cycle1|block\": \"cycle1\",\n  \"sinamon.colorcycle.cycle256|block\": \"cycle256\",\n  \"sinamon.colorcycle.cycle42|block\": \"cycle42\",\n  \"sinamon.colorcycle.cycle64|block\": \"cylce64\",\n  \"sinamon.colorgain.gain16|block\": \"16×gain\",\n  \"sinamon.colorgain.gain1|block\": \"1×gain\",\n  \"sinamon.colorgain.gain4|block\": \"4×gain\",\n  \"sinamon.colorgain.gain60|block\": \"60×gain\",\n  \"sinamon.direction.Stop|block\": \"停止\",\n  \"sinamon.direction.backward|block\": \"後ろ\",\n  \"sinamon.direction.forward|block\": \"前\",\n  \"sinamon.direction.left_rotation|block\": \"左回転\",\n  \"sinamon.direction.left|block\": \"左\",\n  \"sinamon.direction.right_rotation|block\": \"右回転\",\n  \"sinamon.direction.right|block\": \"右\",\n  \"sinamon.direction2.backward|block\": \"後ろ\",\n  \"sinamon.direction2.forward|block\": \"前\",\n  \"sinamon.direction2.left_rotation|block\": \"左回転\",\n  \"sinamon.direction2.right_rotation|block\": \"右回転\",\n  \"sinamon.direction3.backward|block\": \"後ろ\",\n  \"sinamon.direction3.forward|block\": \"前\",\n  \"sinamon.direction4.left_rotation|block\": \"左回転\",\n  \"sinamon.direction4.right_rotation|block\": \"右回転\",\n  \"sinamon.driveForwards|block\": \"待ち時間 (秒)|%second|\",\n  \"sinamon.getBlue|block\": \"Bの値\",\n  \"sinamon.getGreen|block\": \"Gの値\",\n  \"sinamon.getLight|block\": \"明るさ\",\n  \"sinamon.getRed|block\": \"Rの値\",\n  \"sinamon.kyori.long|block\": \"長い\",\n  \"sinamon.kyori.short|block\": \"短い\",\n  \"sinamon.onoff.OFF|block\": \"OFF\",\n  \"sinamon.onoff.ON|block\": \"ON\",\n  \"sinamon.photo_LR_out|block\": \"両方が |%wb| \",\n  \"sinamon.photo_L_out|block\": \"左だけが |%wb|\",\n  \"sinamon.photo_R_out|block\": \"右だけが |%wb| \",\n  \"sinamon.phto_L|block\": \"左のﾗｲﾝｾﾝｻｰ\",\n  \"sinamon.phto_R|block\": \"右のﾗｲﾝｾﾝｻ\",\n  \"sinamon.selectcycle|block\": \"積算量|%cycle|\",\n  \"sinamon.sonar_ping_2|block\": \"超音波距離ｾﾝｻ\",\n  \"sinamon.sonar_ping_3|block\": \"(最小 5cm) 長さが|%limit|cmより|%nagasa|\",\n  \"sinamon.whiteblack.black|block\": \"黒\",\n  \"sinamon.whiteblack.white|block\": \"白\",\n  \"{id:category}Sinamon\": \"しなのカー\",\n  \"{id:group}1 Basic movement\": \"1 基本命令\",\n  \"{id:group}6 Ultrasonic_Distance sensor\": \"6 超音波距離ｾﾝｻ\",\n  \"{id:group}7 photoreflector\": \"7 ﾗｲﾝｾﾝｻ\",\n  \"{id:group}8 color senser\": \"8 ｶﾗｰｾﾝｻ\"\n}","main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><block type=\"device_forever\" id=\"!(?t-abWX.Cd/(R4s%hx\" x=\"0\" y=\"0\"></block></xml>","main.ts":"basic.forever(function () {\r\n\t\r\n})\r\n","pxt.json":"{\n    \"name\": \"pxt-sinamon\",\n    \"version\": \"0.0.0\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"neopixel\": \"github:microsoft/pxt-neopixel#v0.7.5\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.blocks\",\n        \"main.ts\",\n        \"sinamon.ts\",\n        \"_locales/ja/pxt-sinamon-strings.json\",\n        \"_locales/ja/pxt-sinamon-jsdoc-strings.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"3.0.0\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","sinamon.ts":"/* sinano_car V1.1 1023/10/04\r\n超音波センサ\r\n    Tri P14\r\n    Eco P10\r\n左・フォトリフレクター（B input)\r\n    P3\r\n右・フォトリフレクター(A input)\r\n    P4\r\nモータードライバ\r\n    INT1 P2\r\n    INT2 P13\r\n    INT3 P15\r\n    INT4 P16\r\n                Left wheel          Right wheel\r\n                P2      P13         P15     P16\r\n    forward     1       0           0       1\r\n    back        0       1           1       0\r\n    left        0       1           0       1\r\n    right       1       0           1       0\r\n    stop(ﾌﾞﾚｰｷ)  1       1           1       1\r\n    stop(電流遮断)0     0           0         0\r\n左ホイール・フォトセンサー(D input)\r\n    P7\r\n右ホイール・フォトセンサー(C input)\r\n    P6\r\nネオピクセル用\r\n    P9\r\nあまり\r\n    P0, P8,\r\n電圧検出\r\n    P1\r\nカラーセンサー\r\n    I2C\r\n*/\r\n\r\nlet 走行モード = 0\r\nlet ステップモード = 0\r\nlet L_U = 0\r\nlet L_e_pre = 0\r\nlet L_ie = 0\r\nlet L_e = 0\r\nlet L_r = 0\r\nlet L_y = 0\r\nlet R_U = 0\r\nlet R_e_pre = 0\r\nlet R_ie = 0\r\nlet R_e = 0\r\nlet R_r = 0\r\nlet R_y = 0\r\nlet 左カウンター = 0\r\nlet 右カウンター = 0\r\nlet T = 0\r\nlet L_ki = 0\r\nlet L_kp = 0\r\nlet R_ki = 0\r\nlet R_kp = 0\r\nlet p=0\r\n\r\nR_kp = 30\r\nR_ki = 20\r\nL_kp = 30\r\nL_ki = 20\r\n\r\n// 制御周期分だけ待つ処理（ｍｓ）\r\nT = 0.01\r\npins.setPull(DigitalPin.P6, PinPullMode.PullNone)\r\npins.setPull(DigitalPin.P7, PinPullMode.PullNone)\r\nled.enable(false)\r\npins.setEvents(DigitalPin.P6, PinEventType.Pulse)\r\npins.setEvents(DigitalPin.P7, PinEventType.Pulse)\r\n\r\nlet noservo = 0\r\nled.enable(false)\r\nlet color_value = 0\r\nlet volt = 0\r\nlet color_cycle = 10\r\n\r\n\r\nlet neo_sinamon = neopixel.create(DigitalPin.P9, 2, NeoPixelMode.RGB)\r\nneo_sinamon.setBrightness(20)\r\n\r\npins.digitalWritePin(DigitalPin.P2, 0)\r\npins.digitalWritePin(DigitalPin.P13, 0)\r\npins.digitalWritePin(DigitalPin.P15, 0)\r\npins.digitalWritePin(DigitalPin.P16, 0)\r\n\r\n\r\n//% color=\"#ff4500\" weight=94 \r\nnamespace sinamon {\r\n\r\n    export enum direction {\r\n        //% block=\"forward\"\r\n        forward,\r\n        //% block=\"right\",\r\n        right,\r\n        //% block=\"left\",\r\n        left,\r\n        //% block=\"right_rotation\",\r\n        right_rotation,\r\n        //% block=\"left_rotation\",\r\n        left_rotation,\r\n        //% block=\"backward\",\r\n        backward,\r\n        //% block=\"Stop\",\r\n        Stop\r\n    }\r\n\r\n    export enum direction2 {\r\n        //% block=\"forward\"\r\n        forward,\r\n        //% block=\"right_rotation\",\r\n        right_rotation,\r\n        //% block=\"left_rotation\",\r\n        left_rotation,\r\n        //% block=\"backward\",\r\n        backward\r\n    }\r\n\r\n    export enum direction3 {\r\n        //% block=\"forward\"\r\n        forward,\r\n        //% block=\"backward\",\r\n        backward\r\n    }\r\n\r\n    export enum direction4 {\r\n        //% block=\"right_rotation\",\r\n        right_rotation,\r\n        //% block=\"left_rotation\",\r\n        left_rotation\r\n    }\r\n\r\n\r\n    let volt = pins.analogReadPin(AnalogPin.P1) / 500 * 6\r\n\r\n    export enum kyori {\r\n        //% block=\"long\"\r\n        long,\r\n        //% block=\"short\",\r\n        short\r\n    }\r\n\r\n    export enum color_senser {\r\n        //% block=\"Red\"\r\n        Red,\r\n        //% block=\"Green\",\r\n        Green,\r\n        //% block=\"Blue\",\r\n        Blue,\r\n        //% block=\"Light\",\r\n        Light              \r\n    }    \r\n\r\n\r\n    export enum color_scene {\r\n        //% block=\"Red\"\r\n        Red,\r\n        //% block=\"Green\",\r\n        Green,\r\n        //% block=\"Blue\",\r\n        Blue,\r\n        //% block=\"White\"\r\n        White        \r\n    }  \r\n\r\n\r\n    export enum onoff {\r\n        //% block=\"ON\"\r\n        ON,\r\n        //% block=\"OFF\"\r\n        OFF\r\n    }\r\n    export enum whiteblack {\r\n        //% block=\"black\"\r\n        black,\r\n        //% block=\"white\"\r\n        white\r\n    }\r\n\r\n\r\n\r\n\r\n    export enum colorcycle {\r\n        //% block=\"cycle1\"\r\n        cycle1,\r\n        //% block=\"cycle10\",\r\n        cycle10,\r\n        //% block=\"cycle42\",\r\n        cycle42,\r\n        //% block=\"cylce64\",\r\n        cycle64,\r\n        //% block=\"cycle256\",\r\n        cycle256\r\n    }\r\n\r\n    export enum colorgain {\r\n        //% block=\"1×gain\"\r\n        gain1,\r\n        //% block=\"4×gain\",\r\n        gain4,\r\n        //% block=\"16×gain\",\r\n        gain16,\r\n        //% block=\"60×gain\",\r\n        gain60\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    pins.onPulsed(DigitalPin.P6, PulseValue.High, function () {\r\n        右カウンター += 1\r\n    })\r\n    pins.onPulsed(DigitalPin.P6, PulseValue.Low, function () {\r\n        右カウンター += 1\r\n    })\r\n    pins.onPulsed(DigitalPin.P7, PulseValue.High, function () {\r\n        左カウンター += 1\r\n    })\r\n    pins.onPulsed(DigitalPin.P7, PulseValue.Low, function () {\r\n        左カウンター += 1\r\n    })\r\n\r\n    //% color=\"#1E90FF\" weight=93 block=\"Wait time (sec)|%second|\" group=\"1 Basic movement\"\r\n    //% second.min=0 second.max=10 second.defl=1\r\n    export function driveForwards(second: number): void {\r\n        basic.pause(second * 1000);\r\n    }\r\n\r\n\r\n\r\n    //% color=\"#3943c6\" weight=90 \r\n    //% block=\"Move |%sinkou_houkou|,power|%Power|\" group=\"1 Basic movement\"\r\n    //% Power.min=0 Power.max=100 Power.defl=100\r\n    export function car_derection(sinkou_houkou: direction, Power: number): void {\r\n        //pins.setEvents(DigitalPin.P6, PinEventType.None)\r\n        //pins.setEvents(DigitalPin.P7, PinEventType.None)\r\n        Power = Power*10.23\r\n        switch (sinkou_houkou) {\r\n            case direction.forward:\r\n                連続前進(Power)\r\n                break;\r\n            case direction.backward:\r\n                連続後進(Power)\r\n                break;\r\n            case direction.left:\r\n                連続左折(Power)\r\n                break;\r\n            case direction.right:\r\n                連続右折(Power)\r\n                break;\r\n            case direction.right_rotation:\r\n                連続右回転(Power)\r\n                break;\r\n            case direction.left_rotation:\r\n                連続左回転(Power)\r\n                break;\r\n\r\n            case direction.Stop:\r\n                連続停止(0)\r\n                break;\r\n        }\r\n    }\r\n\r\n    //% color=\"#3943c6\" weight=88 \r\n    //% block=\"Move |%sinkou_houkou|, |%time_sec|(sec) ,power|%Power|\" group=\"1 Basic movement\"\r\n    //% Power.min=0 Power.max=100 Power.defl=100\r\n    //% time_sec.min=0 time_sec.max=10 time_sec.defl=0\r\n    export function car_derection2(sinkou_houkou: direction, time_sec: number,Power: number): void {\r\n        //pins.setEvents(DigitalPin.P6, PinEventType.None)\r\n        //pins.setEvents(DigitalPin.P7, PinEventType.None)\r\n        Power =Power*10.23\r\n        switch (sinkou_houkou) {\r\n            case direction.forward:\r\n                連続前進(Power)\r\n                basic.pause(time_sec * 1000);\r\n                連続停止(Power)\r\n                break;\r\n            case direction.left:\r\n                連続左折(Power)\r\n                basic.pause(time_sec * 1000);\r\n                連続停止(Power)\r\n                break;\r\n            case direction.right:\r\n                連続右折(Power)\r\n                basic.pause(time_sec * 1000);\r\n                連続停止(Power)\r\n                break;\r\n            case direction.right_rotation:\r\n                連続右回転(Power)\r\n                basic.pause(time_sec * 1000);\r\n                連続停止(Power)\r\n                break;\r\n            case direction.left_rotation:\r\n                連続左回転(Power)\r\n                basic.pause(time_sec * 1000);\r\n                連続停止(Power)\r\n                break;\r\n            case direction.backward:\r\n                連続後進(Power)\r\n                basic.pause(time_sec * 1000);\r\n                連続停止(Power)\r\n                break;\r\n            case direction.Stop:\r\n                連続停止(Power)\r\n                basic.pause(time_sec * 1000);\r\n                連続停止(Power)\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    //% color=\"#008000\" weight=80 \r\n    //% block=\"Move |%sinkou_houkou|,|%step|step\" group=\"1 Basic movement\"\r\n    //% step.min=0 step.max=100 Power.defl=0\r\n    export function car_stepmove(sinkou_houkou: direction2, step: number): void {\r\n        switch (sinkou_houkou) {\r\n            case direction2.forward:\r\n                ステップ前(step)\r\n                break;\r\n            case direction2.backward:\r\n                ステップ後ろ(step)\r\n                break;\r\n                case direction2.left_rotation:\r\n                ステップ左回転(step)\r\n                break;\r\n                case direction2.right_rotation:\r\n                ステップ右回転(step)\r\n                break;\r\n        }\r\n    }\r\n\r\n    //% color=\"#008000\" weight=85\r\n    //% block=\"Move |%sinkou_houkou|,|%step|cm\" group=\"1 Basic movement\"\r\n    //% step.min=0 step.max=50 Power.defl=0\r\n    export function car_stepmove3(sinkou_houkou: direction3, step: number): void {\r\n        switch (sinkou_houkou) {\r\n            case direction3.forward:\r\n                ステップ前(step*4.1)\r\n                break;\r\n            case direction3.backward:\r\n                ステップ後ろ(step*4.1)\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n    //% color=\"#008000\" weight=83\r\n    //% block=\"Move |%sinkou_houkou|,|%step|degree\" group=\"1 Basic movement\"\r\n    //% step.min=0 step.max=180 Power.defl=90\r\n    export function car_stepmove4(sinkou_houkou: direction4, step: number): void {\r\n        switch (sinkou_houkou) {\r\n            case direction4.right_rotation:\r\n                ステップ右回転(step*0.36)\r\n                break;\r\n            case direction4.left_rotation:\r\n                ステップ左回転(step*0.36)\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\nfunction ステップ前(数値: number) {\r\n    連続停止(0)\r\n    basic.pause(1000);\r\n    ステップモード = 1\r\n    左カウンター = 0\r\n    右カウンター = 0\r\n    走行モード = 0                                //左右の回転数ずれ　修正モードをON\r\n    ステップ動作(数値)\r\n}\r\nfunction ステップ後ろ(数値: number) {\r\n    連続停止(0)\r\n    basic.pause(1000);\r\n    ステップモード = 2\r\n    左カウンター = 0\r\n    右カウンター = 0\r\n    走行モード = 0 \r\n    ステップ動作(数値)\r\n}   \r\nfunction ステップ左回転(数値: number) {\r\n    連続停止(0)\r\n    basic.pause(1000);\r\n    ステップモード = 3\r\n    左カウンター = 0\r\n    右カウンター = 0\r\n    走行モード = 0     \r\n    ステップ動作(数値)\r\n}\r\nfunction ステップ右回転(数値: number) {\r\n    連続停止(0)\r\n    basic.pause(1000);\r\n    ステップモード = 4\r\n    左カウンター = 0\r\n    右カウンター = 0\r\n    走行モード = 0\r\n    ステップ動作(数値)\r\n}\r\n\r\n\r\n\r\nfunction ステップ動作(STEP: number) {\r\n\r\n    右カウンター = 0\r\n    左カウンター = 0\r\n    R_e_pre = 0\r\n    L_e_pre = 0 \r\n    R_ie = 0\r\n    L_ie = 0\r\n\r\n    while (true) {\r\n        basic.pause(10)\r\n        // 現時刻の情報取得\r\n        R_y = 右カウンター\r\n        // 目標値\r\n        R_r = STEP\r\n        // PID制御の式\r\n        R_e = R_r - R_y\r\n        R_ie = R_ie + (R_e + R_e_pre) * T / 2\r\n        R_U = R_kp * R_e + R_ki * R_ie\r\n        if (R_U >= 600) {\r\n            R_U = 600\r\n        } else if (R_U <= 0) {\r\n            R_U = 0\r\n        }\r\n        // 現時刻の情報取得\r\n        L_y = 左カウンター\r\n        // 目標値\r\n        L_r = STEP\r\n        // PID制御の式\r\n        L_e = L_r - L_y\r\n        L_ie = L_ie + (L_e + L_e_pre) * T / 2\r\n        L_U = L_kp * L_e + L_ki * L_ie\r\n        if (L_U >= 600) {\r\n            L_U = 600\r\n        } else if (L_U <= 0) {\r\n            L_U = 0\r\n        }\r\n        //if (左カウンター<15 || 右カウンター<15 ){\r\n            //R_U=R_U/3\r\n            //L_U=L_U/3\r\n        //}\r\n        p=(R_U+L_U)/2\r\n        //serial.writeNumbers([左カウンター, L_U])\r\n        if (左カウンター>右カウンター){\r\n            L_U = L_U*0.5\r\n            R_U = R_U*1    \r\n            }\r\n            else{\r\n            L_U = L_U*1\r\n            R_U = R_U*0.5              \r\n            }\r\n        //serial.writeNumbers([左カウンター, 右カウンター,R_U,L_U])\r\n        if (ステップモード == 1) {                         //前\r\n\r\n            pins.analogWritePin(AnalogPin.P2, L_U)\r\n            pins.digitalWritePin(DigitalPin.P13, 0)\r\n            pins.analogWritePin(AnalogPin.P16, R_U)\r\n            pins.digitalWritePin(DigitalPin.P15, 0)\r\n\r\n        } else {\r\n            if (ステップモード == 2) {                      //後ろ\r\n                pins.analogWritePin(AnalogPin.P15, R_U)\r\n                pins.digitalWritePin(DigitalPin.P16, 0)\r\n                pins.analogWritePin(AnalogPin.P13, L_U)\r\n                pins.digitalWritePin(DigitalPin.P2, 0)\r\n            } else {\r\n                if (ステップモード == 3) {                  //左回転\r\n                    pins.analogWritePin(AnalogPin.P16, R_U)\r\n                    pins.digitalWritePin(DigitalPin.P15, 0)\r\n                    pins.analogWritePin(AnalogPin.P13, L_U)\r\n                    pins.digitalWritePin(DigitalPin.P2, 0)\r\n                } else {\r\n                    if (ステップモード == 4) {                  //右回転\r\n                        pins.analogWritePin(AnalogPin.P15, R_U)\r\n                        pins.digitalWritePin(DigitalPin.P16, 0)\r\n                        pins.analogWritePin(AnalogPin.P2, L_U)\r\n                        pins.digitalWritePin(DigitalPin.P13, 0)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        R_e_pre = R_e\r\n        L_e_pre = L_e\r\n        if (STEP <= L_y && STEP <= R_y) {\r\n            pins.digitalWritePin(DigitalPin.P2, 1)\r\n            pins.digitalWritePin(DigitalPin.P13, 1)\r\n            pins.digitalWritePin(DigitalPin.P15, 1)\r\n            pins.digitalWritePin(DigitalPin.P16, 1)\r\n            走行モード = 0\r\n            basic.pause(200)\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction 連続前進(power: number) {\r\n    if (走行モード != 1){\r\n        左カウンター = 0\r\n        右カウンター = 0\r\n        走行モード = 1\r\n        }                                //左右の回転数ずれ　修正モードをON\r\n    p=power\r\n    pins.analogWritePin(AnalogPin.P2, power)\r\n    pins.digitalWritePin(DigitalPin.P13, 0)\r\n    pins.digitalWritePin(DigitalPin.P15, 0)\r\n    pins.analogWritePin(AnalogPin.P16, power)\r\n}\r\nfunction 連続後進(power: number) {\r\n    左カウンター = 0\r\n    右カウンター = 0\r\n    走行モード = 2                              //左右の回転数ずれ　修正モードをON\r\n    p=power                              \r\n    pins.digitalWritePin(DigitalPin.P2, 0)\r\n    pins.analogWritePin(AnalogPin.P13, power)\r\n    pins.digitalWritePin(DigitalPin.P16, 0)\r\n    pins.analogWritePin(AnalogPin.P15, power)\r\n}\r\n\r\nfunction 連続左回転(power: number) {\r\n    左カウンター = 0\r\n    右カウンター = 0\r\n    p=power\r\n    走行モード = 3\r\n    pins.digitalWritePin(DigitalPin.P2, 0)\r\n    pins.analogWritePin(AnalogPin.P13, power)\r\n    pins.digitalWritePin(DigitalPin.P15, 0)\r\n    pins.analogWritePin(AnalogPin.P16, power)\r\n}\r\nfunction 連続右回転(power: number) {\r\n    左カウンター = 0\r\n    右カウンター = 0 \r\n    走行モード = 4\r\n    p=power\r\n    pins.digitalWritePin(DigitalPin.P13, 0)\r\n    pins.analogWritePin(AnalogPin.P2, power)\r\n    pins.digitalWritePin(DigitalPin.P16, 0)\r\n    pins.analogWritePin(AnalogPin.P15, power)\r\n}\r\nfunction 連続左折(power: number) {\r\n    走行モード = 5\r\n    pins.digitalWritePin(DigitalPin.P13, 0)\r\n    pins.analogWritePin(AnalogPin.P2, 0)\r\n    pins.digitalWritePin(DigitalPin.P15, 0)\r\n    pins.analogWritePin(AnalogPin.P16, power)\r\n}\r\nfunction 連続右折(power: number) {\r\n    走行モード = 6\r\n    pins.digitalWritePin(DigitalPin.P13, 0)\r\n    pins.analogWritePin(AnalogPin.P2, power)\r\n    pins.digitalWritePin(DigitalPin.P16, 0)\r\n    pins.analogWritePin(AnalogPin.P15, 0)\r\n}\r\n\r\nfunction 連続停止(power: number) {\r\n    走行モード = 7\r\n    pins.digitalWritePin(DigitalPin.P2, 1)\r\n    pins.digitalWritePin(DigitalPin.P13, 1)\r\n    pins.digitalWritePin(DigitalPin.P15, 1)\r\n    pins.digitalWritePin(DigitalPin.P16, 1)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//music.play(music.tonePlayable(262, music.beat(BeatFraction.Whole)), music.PlaybackMode.UntilDone)\r\n\r\n    //% color=\"#009A00\" weight=22 blockId=sonar_ping_2 block=\"Distance sensor\" group=\"6 Ultrasonic_Distance sensor\"\r\n    //% advanced=true\r\n    export function sonar_ping_2(): number {\r\n        let d1 = 0;\r\n        let d2 = 0;\r\n\r\n        for (let i = 0; i < 5; i++) {\r\n            // send\r\n            basic.pause(5);\r\n            pins.setPull(DigitalPin.P2, PinPullMode.PullNone);\r\n            pins.digitalWritePin(DigitalPin.P14, 0);\r\n            control.waitMicros(2);\r\n            pins.digitalWritePin(DigitalPin.P14, 1);\r\n            control.waitMicros(10);\r\n            pins.digitalWritePin(DigitalPin.P14, 0);\r\n            // read\r\n            d1 = pins.pulseIn(DigitalPin.P10, PulseValue.High, 500 * 58);\r\n            d2 = d2 + d1;\r\n        }\r\n        return Math.round(Math.idiv(d2 / 5, 58) * 1.5);\r\n    }\r\n\r\n\r\n\r\n\r\n    //% color=\"#009A00\" weight=30 block=\"(minimam 5cm) dstance |%limit| cm  |%nagasa| \" group=\"6 Ultrasonic_Distance sensor\"\r\n    //% limit.min=5 limit.max=30 limit.defl=5\r\n    //% advanced=true\r\n    export function sonar_ping_3(limit: number, nagasa: kyori): boolean {\r\n        let d1 = 0;\r\n        let d2 = 0;\r\n        if (limit < 8) {\r\n            limit = 8\r\n        }\r\n        for (let i = 0; i < 5; i++) {\r\n            // send\r\n            basic.pause(5);\r\n            pins.setPull(DigitalPin.P2, PinPullMode.PullNone);\r\n            pins.digitalWritePin(DigitalPin.P1, 0);\r\n            control.waitMicros(2);\r\n            pins.digitalWritePin(DigitalPin.P14, 1);\r\n            control.waitMicros(10);\r\n            pins.digitalWritePin(DigitalPin.P14, 0);\r\n            // read\r\n            d1 = pins.pulseIn(DigitalPin.P10, PulseValue.High, 500 * 58);\r\n            d2 = d1 + d2;\r\n        }\r\n        switch (nagasa) {\r\n            case kyori.short:\r\n                if (Math.idiv(d2 / 5, 58) * 1.5 < limit) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n                break;\r\n            case kyori.long:\r\n                if (Math.idiv(d2 / 5, 58) * 1.5 < limit) {\r\n                    return false;\r\n                } else {\r\n                    return true;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n    //% color=\"#f071bd\" weight=30 blockId=auto_photo_R block=\"right_photoreflector\" group=\"7 photoreflector\"\r\n    //% advanced=true\r\n    export function phto_R() {\r\n        return pins.digitalReadPin(DigitalPin.P4);\r\n    }\r\n\r\n    //% color=\"#f071bd\" weight=28 blockId=auto_photo_L block=\"left_photoreflector\" group=\"7 photoreflector\"\r\n    //% advanced=true\r\n    export function phto_L() {\r\n        return pins.digitalReadPin(DigitalPin.P3);\r\n    }\r\n\r\n\r\n    //% color=\"#6041f1\"  weight=33 block=\"only right |%wb| \" group=\"7 photoreflector\"\r\n    //% sence.min=10 sence.max=40\r\n    //% advanced=true\r\n    export function photo_R_out(wb: whiteblack): boolean {\r\n\r\n        switch (wb) {\r\n            case whiteblack.black:\r\n                if ((pins.digitalReadPin(DigitalPin.P3) == 1) && (pins.digitalReadPin(DigitalPin.P4) == 0)) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n                break;\r\n            case whiteblack.white:\r\n                if ((pins.digitalReadPin(DigitalPin.P3) == 0) && (pins.digitalReadPin(DigitalPin.P4) == 1)) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    //% color=\"#6041f1\"  weight=34 block=\"onle left |%wb|\" group=\"7 photoreflector\" \r\n    //% advanced=true\r\n    export function photo_L_out(wb: whiteblack): boolean {\r\n\r\n\r\n        switch (wb) {\r\n            case whiteblack.black:\r\n                if\r\n\r\n                    ((pins.digitalReadPin(DigitalPin.P3) == 0) && (pins.digitalReadPin(DigitalPin.P4) == 1)) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n                break;\r\n            case whiteblack.white:\r\n                if ((pins.digitalReadPin(DigitalPin.P3) == 1) && (pins.digitalReadPin(DigitalPin.P4) == 0)) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    //% color=\"#6041f1\"  weight=35 block=\"Both |%wb| \" group=\"7 photoreflector\"\r\n    //% advanced=true\r\n    export function photo_LR_out(wb: whiteblack): boolean {\r\n\r\n        switch (wb) {\r\n            case whiteblack.black:\r\n                if\r\n                    ((pins.digitalReadPin(DigitalPin.P3) == 0) && (pins.digitalReadPin(DigitalPin.P4) == 0)) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n                break;\r\n\r\n            case whiteblack.white:\r\n\r\n                if\r\n                    ((pins.digitalReadPin(DigitalPin.P3) == 1) && (pins.digitalReadPin(DigitalPin.P4) == 1)) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n                break;\r\n        }\r\n\r\n    }\r\n\r\n    /*\r\n        smbus.writeByte(0x81, 0x00)  //0x81=10000001  RGB timing 700ms\r\n        smbus.writeByte(0x81, 0x10)  //16×gain\r\n    \r\n        smbus.writeByte(0x80, 0x03)  //0x03を書くと動作開始\r\n        smbus.writeByte(0x81, 0x2b)  //this.addr 0x29 0x81=10000001 0x2b=00101011\r\n    */\r\n    smbus.writeByte(0x81, 0xF6)  //cycle10\r\n\r\n\r\n    smbus.writeByte(0x80, 0x03)  //0x03を書くと動作開始\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    //% color=\"#ffa500\"  weight=35 block=\"values |%color|\" group=\"8 color senser\"\r\n    //% advanced=true\r\n    export function colorsenser_value(color:color_senser) :number{\r\n        switch (color){\r\n            case color_senser.Light:\r\n                return color_L()\r\n            case color_senser.Red:\r\n                return color_R()\r\n            case color_senser.Green:\r\n                return color_G()                   \r\n            case color_senser.Blue:\r\n                return color_B()\r\n        }\r\n    }\r\n\r\n\r\n    function color_R(){\r\n        return Math.round(rgb()[0] / Math.max(rgb()[0], Math.max(rgb()[1], rgb()[2]))*256)\r\n    }\r\n    function color_G(){\r\n        return Math.round(rgb()[1] / Math.max(rgb()[0], Math.max(rgb()[1], rgb()[2]))*256)\r\n    }\r\n    function color_B(){\r\n        return Math.round(rgb()[2] / Math.max(rgb()[0], Math.max(rgb()[1], rgb()[2]))*256)\r\n    }\r\n    function color_L(){\r\n        let result: Buffer = smbus.readBuffer(0xb4, pins.sizeOf(NumberFormat.UInt16LE) * 4)\r\n        return smbus.unpack(\"HHHH\", result)[0]/color_cycle*10\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    export function rgb(): number[] {\r\n        let result: number[] = raw()\r\n        let clear: number = result.shift()\r\n        for (let x: number = 0; x < result.length; x++) {\r\n            result[x] = result[x] * 255 / clear\r\n        }\r\n        return result\r\n    }\r\n\r\n\r\n    export function raw(): number[] {\r\n\r\n        let result: Buffer = smbus.readBuffer(0xb4, pins.sizeOf(NumberFormat.UInt16LE) * 4)\r\n        return smbus.unpack(\"HHHH\", result)\r\n    }\r\n\r\n\r\n    //% color=\"#ffa500\"  weight=16 blockId=color_temp block=\"color Temperatures value\" group=\"8 color senser\"\r\n    //% advanced=true\r\n    export function color_temp(): number {\r\n        return Math.round(3810 * color_B() / color_R() + 1391)\r\n    }\r\n\r\n\r\n    //% color=\"#ffa500\" weight=88 blockId=selectcycle\r\n    //% block=\"choice |%cycle|\" group=\"8 color senser\"\r\n    //% advanced=true\r\n    export function selectcycle(cycle: colorcycle): void {\r\n        \r\n        switch (cycle) {\r\n            case colorcycle.cycle1:\r\n                color_cycle = 1\r\n                smbus.writeByte(0x81, 0xFF)\r\n                break;\r\n            case colorcycle.cycle10:\r\n                color_cycle = 10\r\n                smbus.writeByte(0x81, 0xF6)\r\n                break;\r\n            case colorcycle.cycle42:\r\n                color_cycle = 42\r\n                smbus.writeByte(0x81, 0xD5)\r\n                break;\r\n            case colorcycle.cycle64:\r\n                color_cycle = 64\r\n                smbus.writeByte(0x81, 0xC0)\r\n                break;\r\n            case colorcycle.cycle256:\r\n                color_cycle = 256\r\n                smbus.writeByte(0x81, 0x00)\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    //% color=\"#ffa500\"  weight=16 blockId=color_ID block=\"color ID\" group=\"8 color senser\"\r\n    //% advanced=true\r\n    export function color_ID(): number {\r\n        /*     黒:0　　赤：1　緑：2　青：3　白:4  */\r\n        let color_ID = 0\r\n        neo_sinamon.showColor(neopixel.colors(NeoPixelColors.Black))\r\n        let R = color_R()\r\n        let G = color_G()\r\n        let B = color_B()\r\n        let L = color_L()\r\n        let maxcolor_value = Math.max(R, Math.max(G, B))\r\n        if (L >50){\r\n            if (maxcolor_value == R) {\r\n                color_ID = 1\r\n            }\r\n            if (maxcolor_value == G) {\r\n                color_ID = 2\r\n            }\r\n            if (maxcolor_value == B) {\r\n                color_ID = 3\r\n            }\r\n            if (L > 250){\r\n                color_ID = 4\r\n            }\r\n        }\r\n        else{\r\n            color_ID = 0\r\n        }               \r\n    return (color_ID) ;\r\n    }\r\n\r\n\r\n\r\n    //% color=\"#ffa500\"  weight=14 block=\"|%scene|color \" group=\"8 color senser\"\r\n    //% advanced=true\r\n    export function color1(scene : color_scene ): boolean {\r\n\r\n        switch (scene) {\r\n            case color_scene.Red:\r\n                if (color_ID() == 1) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n                break;\r\n            case color_scene.Green:\r\n                if (color_ID() == 2) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n                break;\r\n            case color_scene.Blue:\r\n                if (color_ID() == 3) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n                break;\r\n            case color_scene.White:\r\n                if (color_ID() == 4) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n                break;    \r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    namespace smbus {\r\n        export function writeByte(register: number, value: number): void {\r\n            let temp = pins.createBuffer(2);\r\n            temp[0] = register;\r\n            temp[1] = value;\r\n            pins.i2cWriteBuffer(0x29, temp, false);\r\n        }\r\n\r\n\r\n        export function readBuffer(register: number, len: number): Buffer {\r\n            let temp = pins.createBuffer(1);\r\n            temp[0] = register;\r\n            pins.i2cWriteBuffer(0x29, temp, false);\r\n            return pins.i2cReadBuffer(0x29, len, false);\r\n        }\r\n\r\n\r\n        export function unpack(fmt: string, buf: Buffer): number[] {\r\n            let le: boolean = true;\r\n            let offset: number = 0;\r\n            let result: number[] = [];\r\n            let num_format: NumberFormat = 0;\r\n            for (let c = 0; c < fmt.length; c++) {\r\n                switch (fmt.charAt(c)) {\r\n                    case '<':\r\n                        le = true;\r\n                        continue;\r\n                    case '>':\r\n                        le = false;\r\n                        continue;\r\n                    case 'c':\r\n                    case 'B':\r\n                        num_format = le ? NumberFormat.UInt8LE : NumberFormat.UInt8BE; break;\r\n                    case 'b':\r\n                        num_format = le ? NumberFormat.Int8LE : NumberFormat.Int8BE; break;\r\n                    case 'H':\r\n                        num_format = le ? NumberFormat.UInt16LE : NumberFormat.UInt16BE; break;\r\n                    case 'h':\r\n                        num_format = le ? NumberFormat.Int16LE : NumberFormat.Int16BE; break;\r\n                }\r\n                result.push(buf.getNumber(num_format, offset));\r\n                offset += pins.sizeOf(num_format);\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n    basic.forever(function () {\r\n        let n1 = 0\r\n        let n2 = 0\r\n        if (p < 500) {\r\n            n1 = 1\r\n            n2 = 1.8\r\n            }\r\n            else{\r\n            n1 = 0.5\r\n            n2 = 1\r\n            }\r\n        //前進モード\r\n        if (走行モード == 1) {\r\n                if (左カウンター < 右カウンター) {\r\n                pins.analogWritePin(AnalogPin.P2, p*n2)\r\n                pins.analogWritePin(AnalogPin.P16, p*n1)\r\n            } else {\r\n                pins.analogWritePin(AnalogPin.P2, p*n1)\r\n                pins.analogWritePin(AnalogPin.P16, p*n2)\r\n            }\r\n        }\r\n        //後進モード\r\n        if (走行モード == 2) {\r\n            if (左カウンター < 右カウンター) {\r\n                pins.analogWritePin(AnalogPin.P13, p*n2)\r\n                pins.analogWritePin(AnalogPin.P15, p*n1)\r\n            } else {\r\n                pins.analogWritePin(AnalogPin.P13, p*n1)\r\n                pins.analogWritePin(AnalogPin.P15, p*n2)\r\n            }\r\n        }\r\n        //左回転モード\r\n        if (走行モード == 3) {\r\n            if (左カウンター < 右カウンター) {\r\n                pins.analogWritePin(AnalogPin.P13, p*n2)\r\n                pins.analogWritePin(AnalogPin.P16, p*n1)\r\n            } else {\r\n                pins.analogWritePin(AnalogPin.P13, p*n1)\r\n                pins.analogWritePin(AnalogPin.P16, p*n2)\r\n            }\r\n        }\r\n        //右回転モード\r\n        if (走行モード == 4) {\r\n            if (左カウンター < 右カウンター) {\r\n                pins.analogWritePin(AnalogPin.P2, p*n2)\r\n                pins.analogWritePin(AnalogPin.P15, p*n1)\r\n            } else {\r\n                pins.analogWritePin(AnalogPin.P2, p*n1)\r\n                pins.analogWritePin(AnalogPin.P15, p*n2)\r\n            }\r\n        }\r\n        serial.writeNumbers([走行モード,左カウンター, 右カウンター])\r\n    })\r\n\r\n\r\n\r\n\r\n\r\n}\r\n    /*\r\n        //% color=\"#ffa500\" weight=88 blockId=selectgain\r\n        //% block=\"choice |%gain|\" group=\"8 color senser\"\r\n        //% advanced=true\r\n        export function selectgain(gain: colorgain): void {\r\n    \r\n            switch (gain) {\r\n                case colorgain.gain1:\r\n                    smbus.writeByte(0x8C, 0x00)\r\n                    break;\r\n                case colorgain.gain4:\r\n                    smbus.writeByte(0x8C, 0x01)\r\n                    break;\r\n                case colorgain.gain16:\r\n                    smbus.writeByte(0x8C, 0x10)\r\n                    break;\r\n                case colorgain.gain60:\r\n                    smbus.writeByte(0x8C, 0x11)\r\n                    break;\r\n    \r\n            }\r\n        }\r\n    */","test.ts":"// テストはここに来ます。このパッケージが拡張機能として使用されるときにはコンパイルされません。\r\n"}